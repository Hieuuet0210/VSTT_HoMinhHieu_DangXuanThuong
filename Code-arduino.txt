#define BLYNK_TEMPLATE_ID   "TMPL60gp0GoQ3"
#define BLYNK_TEMPLATE_NAME "Watering plants"
#define BLYNK_AUTH_TOKEN    "1dYDvWCaFQLM6-hZftI1HpcAxNyMFE8H"

#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include "BLEDevice.h"

// CONFIG
#define UI_REFRESH_MS       2000UL
#define ADD_LF_AFTER_CMD    1
#define ACK_TIMEOUT_MS      3500UL
#define RX_LINE_MAX         64
#define RESCAN_BACKOFF_MS   1500UL

// WiFi
char ssid[] = "THUONG";
char pass[] = "0392969074";

// HM10 BLE UUID 
static BLEUUID serviceUUID("0000ffe0-0000-1000-8000-00805f9b34fb");
static BLEUUID charUUID   ("0000ffe1-0000-1000-8000-00805f9b34fb");

BLEClient*               client          = nullptr;
BLERemoteCharacteristic* pRemoteChar     = nullptr;
BLEAdvertisedDevice*     myDevice        = nullptr;
bool deviceConnected = false;
bool doConnect       = false;

BlynkTimer timer;

// PARAMETER
int   desiredPump = 0;     // (0/1)
int   desiredMode = 0;     // (0=MAN,1=AUTO)

int   rptPump  = 0;        // pump do STM32 (0/1)
int   rptMode  = 0;        // mode do STM32(0=MAN,1=AUTO)
int   rptPct   = 0;        // pct 0..100
int   rptTemp  = 0;        // 0..999

// WAIT ACK
bool  waitingK     = false;
unsigned long waitDeadline = 0;


#define INBOX_LINES 8
static char    inbox[INBOX_LINES][RX_LINE_MAX];
static uint8_t inLen[INBOX_LINES];
static volatile uint8_t inHead = 0, inTail = 0;

static char    rxLine[RX_LINE_MAX];
static uint8_t rxLen = 0;

// ===== Helpers =====
static inline bool isDigit3(char a, char b, char c) {
  return (a>='0'&&a<='9') && (b>='0'&&b<='9') && (c>='0'&&c<='9');
}

static void inboxPush(const char* buf, uint8_t len) {
  uint8_t nextHead = (uint8_t)((inHead + 1) % INBOX_LINES);
  if (nextHead == inTail) {
    // tràn: bỏ dòng cũ nhất
    inTail = (uint8_t)((inTail + 1) % INBOX_LINES);
  }
  uint8_t copyLen = (len >= RX_LINE_MAX) ? (RX_LINE_MAX - 1) : len;
  memcpy(inbox[inHead], buf, copyLen);
  inbox[inHead][copyLen] = '\0';
  inLen[inHead] = copyLen;
  inHead = nextHead;
}

static bool inboxPop(char* out, uint8_t& lenOut) {
  if (inTail == inHead) return false;
  lenOut = inLen[inTail];
  memcpy(out, inbox[inTail], lenOut + 1);
  inTail = (uint8_t)((inTail + 1) % INBOX_LINES);
  return true;
}

static void sanitizeLine(char* buf, uint8_t& len) {
  // bỏ \r\n ở cuối nếu có
  if (len >= 1 && buf[len-1] == '\n') { buf[--len] = '\0'; }
  if (len >= 1 && buf[len-1] == '\r') { buf[--len] = '\0'; }
}

static void parseFrameCore(const char* s, uint8_t n) {
  // Hỗ trợ: S/K y z ttt [hhh]
  if (!(n == 6 || n == 9)) return;

  char t = s[0];              // 'S' | 'K'
  char y = s[1];              // '0' | '1'
  char z = s[2];              // 'A' | 'M'
  char a = s[3], b = s[4], c = s[5]; // pct

  if (!((t=='S'||t=='K') && (y=='0'||y=='1') && (z=='A'||z=='M') && isDigit3(a,b,c))) return;

  int pct = (a - '0')*100 + (b - '0')*10 + (c - '0');
  if (pct < 0 || pct > 100) return;

  int temp = rptTemp;
  if (n == 9) {
    char ta = s[6], tb = s[7], tc = s[8];
    if (!isDigit3(ta,tb,tc)) return;
    temp = (ta - '0')*100 + (tb - '0')*10 + (tc - '0');
  }

  int pump = (y=='1') ? 1 : 0;
  int mode = (z=='A') ? 1 : 0;


  if (t=='K') {
    rptPump = pump; rptMode = mode; rptPct = pct; rptTemp = temp;
    waitingK = false; waitDeadline = 0;
    Blynk.virtualWrite(V1, rptPump);
    Blynk.virtualWrite(V2, rptPct);
    Blynk.virtualWrite(V3, rptMode);
    Blynk.virtualWrite(V4, rptTemp);
    Serial.printf("[RX K] pump=%d mode=%d pct=%d temp=%d\n", rptPump, rptMode, rptPct, rptTemp);
  } else {
    rptPump = pump; rptMode = mode; rptPct = pct; rptTemp = temp;
    Blynk.virtualWrite(V1, rptPump);
    Blynk.virtualWrite(V2, rptPct);
    Blynk.virtualWrite(V3, rptMode);
    Blynk.virtualWrite(V4, rptTemp);
    Serial.printf("[RX S] pump=%d mode=%d pct=%d temp=%d\n", rptPump, rptMode, rptPct, rptTemp);
  }
}

void processBleInbox() {
  char line[RX_LINE_MAX];
  uint8_t n;
  while (inboxPop(line, n)) {
    sanitizeLine(line, n);
    if (n == 0) continue;
    parseFrameCore(line, n);
  }
}

//BLE notify callback 
void notifyCallback(BLERemoteCharacteristic* /*ch*/, uint8_t* pData, size_t length, bool /*isNotify*/) {
  for (size_t i = 0; i < length; i++) {
    char c = (char)pData[i];
    if (c == '\n') {
      if (rxLen < RX_LINE_MAX-1) rxLine[rxLen++] = c;
      rxLine[rxLen] = '\0';
      inboxPush(rxLine, rxLen);   
      rxLen = 0;                  
    } else {
      if (rxLen < RX_LINE_MAX-1) {
        rxLine[rxLen++] = c;
      } else {
        // trượt đuôi
        memmove(rxLine, rxLine+1, RX_LINE_MAX-2);
        rxLine[RX_LINE_MAX-2] = c;
        rxLen = RX_LINE_MAX-1;
      }
    }
  }
}

// Scan callback
class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) override {

    if ((advertisedDevice.haveServiceUUID() &&
         advertisedDevice.isAdvertisingService(serviceUUID)) ||
        (advertisedDevice.getName() == "HMSoft")) {
      if (myDevice) { delete myDevice; myDevice = nullptr; }
      myDevice = new BLEAdvertisedDevice(advertisedDevice);
      advertisedDevice.getScan()->stop();
      doConnect = true;
    }
  }
};

// Connect HM10
void connectToHM10() {
  Serial.println("[BLE] Connecting to HM10...");

  if (client) { delete client; client = nullptr; }
  client = BLEDevice::createClient();

  if (!client->connect(myDevice)) {
    Serial.println("[BLE] Connect failed.");
    return;
  }
  Serial.println("[BLE] Connected.");

  BLERemoteService* service = client->getService(serviceUUID);
  if (!service) { Serial.println("[BLE] Service FFE0 not found."); client->disconnect(); return; }

  pRemoteChar = service->getCharacteristic(charUUID);
  if (!pRemoteChar) { Serial.println("[BLE] Char FFE1 not found."); client->disconnect(); return; }

  if (pRemoteChar->canNotify()) {
    pRemoteChar->registerForNotify(notifyCallback);
  } else {
    Serial.println("[BLE] Characteristic can't notify.");
  }

  Serial.println("[BLE] HM10 ready.");
  deviceConnected = true;

  if (WiFi.status()==WL_CONNECTED) Blynk.virtualWrite(V0, 1);
}

//non-blocking write
static void bleSendChar(uint8_t c, bool addLF) {
  if (!(deviceConnected && pRemoteChar && pRemoteChar->canWrite())) {
    Serial.println("[TX CMD] BLE NOT READY");
    return;
  }
  uint8_t b = c;
  pRemoteChar->writeValue(&b, 1, /*withResponse=*/false);
#if ADD_LF_AFTER_CMD
  if (addLF) {
    uint8_t lf = '\n';
    pRemoteChar->writeValue(&lf, 1, /*withResponse=*/false);
  }
#endif
  Serial.printf("[TX CMD] '%c' (0x%02X)%s\n", c, c, addLF ? " + LF" : "");
  delay(1);
  yield();
}

// UI/Status push low + watchdog 
static uint32_t lastUi = 0;

void pushToBlynkSlow() {
  Blynk.virtualWrite(V0, (WiFi.status()==WL_CONNECTED && deviceConnected) ? 1 : 0);

  uint32_t now = millis();
  if (now - lastUi >= UI_REFRESH_MS) {
    Serial.printf("[STATUS] WiFi=%d | BLE=%d | pct=%d | temp=%d | pump=%d | mode=%d | waitingK=%d\n",
                  (WiFi.status() == WL_CONNECTED), deviceConnected,
                  rptPct, rptTemp, rptPump, rptMode, waitingK);
    lastUi = now;
  }

  if (waitingK && now > waitDeadline) {
    Serial.println("[WAITING_K] timeout -> back to normal");
    waitingK = false;
    waitDeadline = 0;
  }

  if (!Blynk.connected()) {
    Blynk.connect(1500); 
  }
}

// Blynk handlers
// V1: Pump 0/1 -> '1'/'0'
BLYNK_WRITE(V1) {
  desiredPump = param.asInt();
  Serial.printf("[APP] desiredPump=%d\n", desiredPump);
  bleSendChar(desiredPump ? '1' : '0', ADD_LF_AFTER_CMD);

  // waiting ACK K… 
  waitingK = true;
  waitDeadline = millis() + ACK_TIMEOUT_MS;
}

// V3: Mode 0/1 -> 'M'/'A'
BLYNK_WRITE(V3) {
  desiredMode = param.asInt();
  Serial.printf("[APP] desiredMode=%d\n", desiredMode);
  bleSendChar(desiredMode ? 'A' : 'M', ADD_LF_AFTER_CMD);

  waitingK = true;
  waitDeadline = millis() + ACK_TIMEOUT_MS;
}

BLYNK_CONNECTED() {
  Serial.println("[BLYNK] connected");
}

// setup / loop
void setup() {
  Serial.begin(115200);
  Serial.println("\n[BOOT] ESP32 start (1-char TX, S/K RX)...");

  WiFi.begin(ssid, pass);
  Serial.print("[WiFi] Connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(250);
    Serial.print(".");
    yield();
  }
  Serial.print("\n[WiFi] IP: "); Serial.println(WiFi.localIP());

  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);

  Blynk.virtualWrite(V0, 0);

  BLEDevice::init("");
  BLEScan* scan = BLEDevice::getScan();
  scan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  scan->setActiveScan(true);
  Serial.println("[BLE] Scanning for HM10...");
  scan->start(10, false);

  // Timer: Blynk watchdog + status + BLE inbox
  timer.setInterval(250, pushToBlynkSlow);
  timer.setInterval(50,  processBleInbox);
}

void loop() {
  Blynk.run();
  timer.run();

  if (doConnect && !deviceConnected) {
    connectToHM10();
    doConnect = false;
  }

  if (deviceConnected && !client->isConnected()) {
    Serial.println("[BLE] Disconnected. Rescanning...");
    deviceConnected = false;
    Blynk.virtualWrite(V0, 0);

    if (client) { delete client; client = nullptr; }
    delay(RESCAN_BACKOFF_MS);
    BLEDevice::getScan()->start(10, false);
  }

  delay(1);
  yield();
}
